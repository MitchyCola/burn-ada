# Proof-of-Burn Challenge üî•

![Alt text](Grilled_Ada.gif?raw=true)

## Introduction üëã
Some members of the cryptocurrency community requested a proof-of-burn mechanism on the Cardano network. The belief is that the systematic destruction of coins, "burning", will increase the scarcity of the remaining coins and should artificially inflate the demand for the coins. This feature has been requested in the Cardano ecosystem due to the Ethereum network incorporating [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Charles Hoskinson got so many messages requesting this feature, that he issued a [challenge](https://www.youtube.com/watch?v=KaLZJs5Y_rE) for developers to engineer a system that would allow people to burn the coins that they wish to destroy.

My stance on Proof-of-Burn is that people should not be forced to destroy their money when they want to perform mundane transactions. I believe that this incentivizes the hoarding of cryptocurrency, and will mainly benefit the people who already have a massive sum of crypto. Now, I do believe each and every person has the right to use their legally owned crypto however they desire. So, if people are willing to volunteer their crypto for the sake of ultrasound money ü¶á, then more power to them.

I decided to make my own implementation of Proof-of-Burn because I thought it would be a fun, little project that would also give me some experience developing on Cardano.

---

## Development üë®üèΩ‚Äçüíª
In essence, there are two methods a person could use to burn Ada, both of these methods would involve sending the Ada to burn address:
 
    1. The first method would be to write a Plutus script that would create a smart contract with infinite time-to-live and would also have a redeemer that would be impossible to satisfy, then people would send their Ada to the script address where it would remain forever.

    2. The second method would entail creating a regular address, but the private keys for the address would never be saved or seen. Meaning, any Ada that would be sent to that address can never be spent.

Personally, I decided to continue with the second method because it is much easier to grasp, mentally. If you would like an example of a solution that is similar to the way I described the first method, then I would recommend looking into [Iagon's solution](https://blog.iagon.com/iagons-solution-to-the-cardano-proof-of-burn-challenge/). However, their implementation of the solution requires each person to submit their own smart contract. Which generates a new burn address every time a different transaction is submitted. I want the users to have a simplified experience, which requires more work on my end.

### Methodology üìö
After looking into how I could derive a Cardano address, I found that IOHK provides a [repository](https://github.com/input-output-hk/cardano-addresses) that contains the Haskell code necessary to generate an address. This code is also utilized in the precompiled binaries that are provided by IOHK. However, it is not good practice to implement these binaries directly in a GitHub repository, since the file sizes are relatively large. To create a burn address, it is important that the root keys are never recorded. With Haskell, the generation of the burn address can occur by stringing together several functions.

Once I figured out the process for creating a burn address, I faced the issue of being able to create the address so that people can verify that I actually used the code that I wrote, and that I am not using an address that I own. As the saying goes in crypto "Trust, but verify". The issue was that I could not easily prove that the code that I execute on my local machine is the exact same code that is published on [my GitHub repository](https://github.com/MitchyCola/burn-ada). 

I could have gotten the code signed and certified by a centralized entity, but it still would not have solved the issue of people needing to trust that I did everything above board. Also, this is crypto, and we do not take kindly to centralized entities. 

![Alt text](We_dont_take_kindly.gif?raw=true)

### Solution üßê
I determined that I needed to have a remote machine execute the portion of the code that is responsible for creating a random address, with a record of the results. GitHub provides a useful feature that they call Actions. These Actions are essentially virtual machines called "runners" and are hosted by GitHub. These runners can execute the code from a GitHub repository. After some clever manipulation, these Actions can be used to verify that the burn address was generated by the exact code that has been pushed to the [my GitHub repository](https://github.com/MitchyCola/burn-ada). 

With the help of a few shell scripts, the Github Action will use the code on the GitHub repository to generate a burn address and build a transaction that I will then submit to the blockchain via my personal Cardano node. This transaction will mint an NFT that will be submitted to the burn address so that the burn address can be easily identified. The minting policy will utilize Plutus so that the NFT can be instantaneously created once the transaction is submitted. For continuity, the name of the NFT will be the short-hand version of the GitHub commit hash that was used to create the transaction.

GitHub Actions automatically creates a record of the code that was executed, while also giving the option to upload any output files that were generated (called artifacts). However, the way that GitHub handles these files, the artifacts are not stored indefinitely and will be removed after 90 days. In order to keep a record of the artifacts, the GitHub Action that I wrote pushed all of the output files to a new branch in my repository. By doing so, the artifacts will have a reference to the commit hash that they were created from and will remain public for the lifetime of the repository.

### Tragedy Strikes üòñ
I was testing the scripts that were used to build the transaction and to submit it to the blockchain, trying to see what kind of errors will pop up. When I was able to successfully submit the transaction, I realized the errors of my ways when I set the change address as the burn address that was generated ü§¶üèΩ‚Äç‚ôÇÔ∏è. This sent all of my testnet funds (tAda) to be burned. The good news is that I had a successful test run of burning testnet Ada, albeit with some lessons learned. Feel free to go and laugh at my mistake by viewing the testnet transaction [here](https://testnet.adatools.io/transactions/92bf3115e0d972738e299e694d1d3f98921b58a16dd8a878d896d32023694e51).

![Alt text](Oops_Burned_Ada.gif?raw=true)

---

## Deployment üì¶
After the successful submission of the [transaction]() and creation of the [NFT](), now it is time to deliver the results to the people.

I created a simple application with Flutter üê¶ so that people can share this with their Ethereum Maxi friends that are willing to burn any amount of Ada. 

üëâ Here is the website: https://burn-ada.app üëà

This app is very simple and I do have plans to update it in the future if there is enough activity. I am thinking about including a ticker for how much Ada has been sent to the burn address, and maybe even direct integration with a node so that transactions can be created inside the app if things really ramp up. 

Once the Plutus Application Backend has been fully released, I also have ideas about giving an NFT to any person that sends enough Ada to the burn address. The amount of Ada will be determined at later date, once all of the fees for such a transaction have been determined.

---

## Culmination
I had fun with this project, it was definitely a good learning experience. There were a fair share of walls that I ran head-first into, each requiring their own creative solution. 

The code has finally reached to a point where I feel comfortable sharing the initial release. There are a few more stretch goals that I would like to acheive at some point in the future, but I want to move on to other things in the mean time. 

If I peaked your interest qith this article, feel free to check the [YouTube video]() that I uploaded. This video briefly goes over the actual code and shows me submitting the initial transaction to the burn address.

Again, there is also [my GitHub repository](https://github.com/MitchyCola/burn-ada) if you want to sink your teeth into some code.

‚úåÔ∏è Until next time.

![Alt text](smell-you-later.gif?raw=true)